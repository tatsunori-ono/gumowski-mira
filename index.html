<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gumowski–Mira Map</title>

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }

    #hud {
      position: fixed;
      inset: 0;
      z-index: 10;
      pointer-events: none;
      color: rgba(255,255,255,0.92);
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      text-shadow: 0 0 10px rgba(0,0,0,0.65);
    }

    #formulaBox {
      position: absolute;
      left: 34px;
      top: 28px;
      max-width: min(760px, 62vw);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.18);
    }

    #stepBox {
      position: absolute;
      right: 34px;
      top: 28px;
      font-size: 22px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(0,0,0,0.16);
      letter-spacing: 0.3px;
    }

    #ui {
      position: absolute;
      left: 34px;
      bottom: 22px;
      pointer-events: auto;
      background: rgba(0,0,0,0.25);
      border-radius: 14px;
      padding: 12px 12px 10px;
      width: min(420px, 92vw);
      color: rgba(255,255,255,0.92);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      font-size: 13px;
    }

    #ui h3 {
      margin: 0 0 8px;
      font-size: 13px;
      font-weight: 650;
      opacity: 0.95;
    }

    .row {
      display: grid;
      grid-template-columns: 120px 1fr 70px;
      gap: 10px;
      align-items: center;
      margin: 8px 0;
    }

    .row label { opacity: 0.9; }
    .row input[type="range"] { width: 100%; }
    .row .val { text-align: right; opacity: 0.95; font-variant-numeric: tabular-nums; }

    .btnRow {
      display: flex;
      gap: 8px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    button, select {
      pointer-events: auto;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.18);
      color: rgba(255,255,255,0.92);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      outline: none;
    }

    button:hover, select:hover { background: rgba(255,255,255,0.14); }
    button:active { transform: translateY(1px); }

    .hint {
      margin-top: 10px;
      opacity: 0.80;
      line-height: 1.35;
    }

    .katex { font-size: 1.05em; }
  </style>
</head>

<body>
  <div id="hud">
    <div id="formulaBox"></div>
    <div id="stepBox">Step : 0</div>

    <div id="ui">
      <h3>Gumowski–Mira (map) · three.js</h3>

      <div class="row">
        <label>Mode</label>
        <select id="modeSel">
          <option value="grid" selected>Grid deformation (dots)</option>
          <option value="ink">Ink / marbling (feedback)</option>
        </select>
        <div class="val"></div>
      </div>

      <div class="row">
        <label>μ (mu)</label>
        <input id="mu" type="range" min="0" max="1" step="0.0001" value="0.1035">
        <div class="val" id="muVal">0.1035</div>
      </div>

      <div class="row">
        <label>Iterations / frame</label>
        <input id="iters" type="range" min="1" max="12" step="1" value="2">
        <div class="val" id="itersVal">2</div>
      </div>

      <div class="row">
        <label>Point size</label>
        <input id="ptSize" type="range" min="0.5" max="6" step="0.1" value="1.6">
        <div class="val" id="ptSizeVal">1.6</div>
      </div>

      <div class="row">
        <label>Feedback decay</label>
        <input id="decay" type="range" min="0.94" max="0.999" step="0.001" value="0.985">
        <div class="val" id="decayVal">0.985</div>
      </div>

      <div class="row">
        <label>Blur</label>
        <input id="blur" type="range" min="0" max="1" step="0.01" value="0.28">
        <div class="val" id="blurVal">0.28</div>
      </div>

      <div class="row">
        <label>Edge strength</label>
        <input id="edge" type="range" min="0" max="16" step="0.1" value="7.5">
        <div class="val" id="edgeVal">7.5</div>
      </div>

      <div class="btnRow">
        <button id="resetBtn">Reset (R)</button>
        <button id="clearBtn">Clear ink buffer</button>
        <button id="toggleBtn">Toggle mode (G / I)</button>
      </div>

      <div class="hint">
        Keys: <b>R</b> reset · <b>G</b> grid mode · <b>I</b> ink mode · Drag to pan · Wheel to zoom
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // x_{n+1} = y_n + f(x_n)
    // y_{n+1} = f(x_{n+1}) - x_n
    // where f(x) = μx + 2(1-μ)x²/(1+x²)

    const state = {
      mode: "grid",
      mu: 0.1035,
      step: 0,
      viewHalfHeight: 8.5,
      itersPerFrame: 2,
      gridN: 170,
      gridRange: 2.7,
      inkN: 120000,
      inkRange: 3.0,
      pointSize: 1.6,
      decay: 0.985,
      blur: 0.28,
      edgeStrength: 7.5,
      maxAbs: 60.0
    };

    let renderer, simScene, orthoCam, controls;
    let points, geom, matPoints;
    let xArr, yArr, posArr;
    let rtA, rtB, rtPts;
    let quadScene, quadCam, feedbackMat, displayMat;
    let quadFeedback, quadDisplay;

    const FULLSCREEN_VS = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;

    const elFormulaBox = document.getElementById("formulaBox");
    const elStepBox    = document.getElementById("stepBox");
    const modeSel      = document.getElementById("modeSel");

    const sliders = {
      mu:    { el: document.getElementById("mu"),     val: document.getElementById("muVal") },
      iters: { el: document.getElementById("iters"),  val: document.getElementById("itersVal") },
      ptSize:{ el: document.getElementById("ptSize"), val: document.getElementById("ptSizeVal") },
      decay: { el: document.getElementById("decay"),  val: document.getElementById("decayVal") },
      blur:  { el: document.getElementById("blur"),   val: document.getElementById("blurVal") },
      edge:  { el: document.getElementById("edge"),   val: document.getElementById("edgeVal") },
    };

    document.getElementById("resetBtn").addEventListener("click", () => resetSimulation(true));
    document.getElementById("clearBtn").addEventListener("click", clearInkBuffers);
    document.getElementById("toggleBtn").addEventListener("click", () => {
      state.mode = state.mode === "ink" ? "grid" : "ink";
      syncUI();
      resetSimulation(true);
    });

    modeSel.addEventListener("change", () => {
      state.mode = modeSel.value;
      resetSimulation(true);
    });

    sliders.mu.el.addEventListener("input", () => {
      state.mu = parseFloat(sliders.mu.el.value);
      sliders.mu.val.textContent = state.mu.toFixed(4);
      renderFormula();
    });

    sliders.iters.el.addEventListener("input", () => {
      state.itersPerFrame = +sliders.iters.el.value;
      sliders.iters.val.textContent = state.itersPerFrame;
    });

    sliders.ptSize.el.addEventListener("input", () => {
      state.pointSize = parseFloat(sliders.ptSize.el.value);
      sliders.ptSize.val.textContent = state.pointSize.toFixed(1);
      if (matPoints) matPoints.size = state.pointSize;
    });

    sliders.decay.el.addEventListener("input", () => {
      state.decay = parseFloat(sliders.decay.el.value);
      sliders.decay.val.textContent = state.decay.toFixed(3);
    });

    sliders.blur.el.addEventListener("input", () => {
      state.blur = parseFloat(sliders.blur.el.value);
      sliders.blur.val.textContent = state.blur.toFixed(2);
    });

    sliders.edge.el.addEventListener("input", () => {
      state.edgeStrength = parseFloat(sliders.edge.el.value);
      sliders.edge.val.textContent = state.edgeStrength.toFixed(1);
    });

    window.addEventListener("keydown", (e) => {
      if (e.key === "r" || e.key === "R") resetSimulation(true);
      if (e.key === "g" || e.key === "G") { state.mode = "grid"; syncUI(); resetSimulation(true); }
      if (e.key === "i" || e.key === "I") { state.mode = "ink";  syncUI(); resetSimulation(true); }
    });

    init();
    resetSimulation(true);
    animate();

    function init() {
      renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.setClearColor(0x000000, 1);
      document.body.appendChild(renderer.domElement);

      orthoCam = new THREE.OrthographicCamera(-1, 1, 1, -1, -10, 10);
      orthoCam.position.set(0, 0, 1);
      orthoCam.lookAt(0, 0, 0);

      simScene = new THREE.Scene();

      controls = new OrbitControls(orthoCam, renderer.domElement);
      controls.enableRotate = false;
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.zoomSpeed = 1.0;
      controls.panSpeed = 0.9;
      controls.screenSpacePanning = true;

      const spriteTex = makeSpriteTex();

      matPoints = new THREE.PointsMaterial({
        map: spriteTex,
        alphaMap: spriteTex,
        transparent: true,
        opacity: 0.10,
        color: 0xffffff,
        size: state.pointSize,
        sizeAttenuation: false,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(new Float32Array(3), 3));
      geom.attributes.position.setUsage(THREE.DynamicDrawUsage);

      points = new THREE.Points(geom, matPoints);
      points.frustumCulled = false;
      simScene.add(points);

      initFeedbackPipeline();

      window.addEventListener("resize", onResize);
      onResize();
      syncUI();
      renderFormula();
    }

    function initFeedbackPipeline() {
      const mkRT = () => new THREE.WebGLRenderTarget(1, 1, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        depthBuffer: false,
        stencilBuffer: false
      });

      rtA = mkRT();  rtB = mkRT();  rtPts = mkRT();

      quadScene = new THREE.Scene();
      quadCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      feedbackMat = new THREE.ShaderMaterial({
        uniforms: {
          uPrev:    { value: null },
          uAdd:     { value: null },
          uTexel:   { value: new THREE.Vector2(1/512, 1/512) },
          uDecay:   { value: state.decay },
          uAddGain: { value: 1.0 },
          uBlur:    { value: state.blur }
        },
        vertexShader: FULLSCREEN_VS,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          uniform sampler2D uPrev, uAdd;
          uniform vec2 uTexel;
          uniform float uDecay, uAddGain, uBlur;

          vec4 blur5(sampler2D tex, vec2 uv) {
            vec4 c  = texture2D(tex, uv) * 0.36;
            c += texture2D(tex, uv + vec2( uTexel.x, 0.0)) * 0.16;
            c += texture2D(tex, uv + vec2(-uTexel.x, 0.0)) * 0.16;
            c += texture2D(tex, uv + vec2(0.0,  uTexel.y)) * 0.16;
            c += texture2D(tex, uv + vec2(0.0, -uTexel.y)) * 0.16;
            return c;
          }

          void main() {
            vec4 base = mix(texture2D(uPrev, vUv), blur5(uPrev, vUv), uBlur);
            gl_FragColor = clamp(base * uDecay + texture2D(uAdd, vUv) * uAddGain, 0.0, 1.0);
          }
        `,
        depthWrite: false, depthTest: false
      });

      displayMat = new THREE.ShaderMaterial({
        extensions: { derivatives: true },
        uniforms: {
          uTex:   { value: null },
          uEdge:  { value: state.edgeStrength },
          uGamma: { value: 1.0 }
        },
        vertexShader: FULLSCREEN_VS,
        fragmentShader: `
          precision highp float;
          varying vec2 vUv;
          uniform sampler2D uTex;
          uniform float uEdge, uGamma;

          vec3 palette(float t) {
            vec3 lo  = vec3(0.0, 0.06, 0.06);
            vec3 mid = vec3(0.06, 0.35, 0.34);
            vec3 hi  = vec3(0.88, 0.98, 1.00);
            return mix(mix(lo, mid, smoothstep(0.0, 0.45, t)),
                       hi, smoothstep(0.45, 1.0, t));
          }

          void main() {
            float t = texture2D(uTex, vUv).r;

            float edge = clamp(length(vec2(dFdx(t), dFdy(t))) * uEdge, 0.0, 1.0);
            vec3 col = mix(palette(t), vec3(0.0), edge);

            // vignette
            float vig = smoothstep(0.92, 0.25, length(vUv - 0.5));
            col *= vig;
            col = pow(col, vec3(1.0 / max(0.001, uGamma)));

            gl_FragColor = vec4(col, 1.0);
          }
        `,
        depthWrite: false, depthTest: false
      });

      const quadGeo = new THREE.PlaneGeometry(2, 2);
      quadFeedback = new THREE.Mesh(quadGeo, feedbackMat);
      quadDisplay  = new THREE.Mesh(quadGeo, displayMat);
      quadFeedback.frustumCulled = false;
      quadDisplay.frustumCulled  = false;

      quadScene.add(quadDisplay);
      quadFeedback.visible = false;
      quadScene.add(quadFeedback);
    }

    function onResize() {
      renderer.setSize(innerWidth, innerHeight);

      const aspect = innerWidth / innerHeight;
      const h = state.viewHalfHeight;
      orthoCam.left   = -h * aspect;
      orthoCam.right  =  h * aspect;
      orthoCam.top    =  h;
      orthoCam.bottom = -h;
      orthoCam.updateProjectionMatrix();

      const w2 = Math.floor(innerWidth  * Math.min(devicePixelRatio, 2));
      const h2 = Math.floor(innerHeight * Math.min(devicePixelRatio, 2));
      rtA.setSize(w2, h2);
      rtB.setSize(w2, h2);
      rtPts.setSize(w2, h2);
      feedbackMat.uniforms.uTexel.value.set(1 / w2, 1 / h2);
      clearInkBuffers();
    }

    function makeSpriteTex() {
      const sz = 128;
      const c = document.createElement("canvas");
      c.width = c.height = sz;
      const ctx = c.getContext("2d");
      const g = ctx.createRadialGradient(sz/2, sz/2, 0, sz/2, sz/2, sz/2);
      g.addColorStop(0.0,  "rgba(255,255,255,1.0)");
      g.addColorStop(0.25, "rgba(255,255,255,0.65)");
      g.addColorStop(1.0,  "rgba(255,255,255,0.0)");
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, sz, sz);
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.LinearSRGBColorSpace;
      return tex;
    }

    function syncUI() {
      modeSel.value = state.mode;
      sliders.mu.el.value     = state.mu;
      sliders.iters.el.value  = state.itersPerFrame;
      sliders.ptSize.el.value = state.pointSize;
      sliders.decay.el.value  = state.decay;
      sliders.blur.el.value   = state.blur;
      sliders.edge.el.value   = state.edgeStrength;

      sliders.mu.val.textContent     = state.mu.toFixed(4);
      sliders.iters.val.textContent  = state.itersPerFrame;
      sliders.ptSize.val.textContent = state.pointSize.toFixed(1);
      sliders.decay.val.textContent  = state.decay.toFixed(3);
      sliders.blur.val.textContent   = state.blur.toFixed(2);
      sliders.edge.val.textContent   = state.edgeStrength.toFixed(1);

      if (matPoints) matPoints.size = state.pointSize;
    }

    function renderFormula() {
      const latex = `\\begin{aligned}
        x_{n+1} &= y_n + \\mu x_n + \\frac{2(1-\\mu)x_n^2}{1 + x_n^2} \\\\[6pt]
        y_{n+1} &= \\mu x_{n+1} + \\frac{2(1-\\mu)x_{n+1}^2}{1 + x_{n+1}^2} - x_n \\\\[10pt]
        \\mu &= ${state.mu.toFixed(4)}
      \\end{aligned}`;

      if (window.katex) {
        window.katex.render(latex, elFormulaBox, { throwOnError: false, displayMode: true });
      } else {
        elFormulaBox.textContent = "Loading formula\u2026";
        setTimeout(renderFormula, 60);
      }
    }

    function resetSimulation(clearBufs) {
      state.step = 0;
      elStepBox.textContent = "Step : 0";

      if (state.mode === "grid") {
        buildGridPoints();
        matPoints.opacity = 1.0;
      } else {
        buildInkPoints();
        matPoints.opacity = 0.08;
      }
      matPoints.color.set(0xffffff);

      if (clearBufs) clearInkBuffers();
      renderFormula();
    }

    function clearInkBuffers() {
      for (const rt of [rtA, rtB, rtPts]) {
        renderer.setRenderTarget(rt);
        renderer.clear(true, true, true);
      }
      renderer.setRenderTarget(null);
    }

    function buildGridPoints() {
      const N = state.gridN, total = N * N, L = state.gridRange;
      xArr   = new Float32Array(total);
      yArr   = new Float32Array(total);
      posArr = new Float32Array(total * 3);

      let idx = 0;
      for (let j = 0; j < N; j++) {
        const y0 = ((j / (N - 1)) * 2 - 1) * L;
        for (let i = 0; i < N; i++) {
          const x0 = ((i / (N - 1)) * 2 - 1) * L;
          xArr[idx] = x0;  yArr[idx] = y0;
          posArr[idx*3] = x0;  posArr[idx*3+1] = y0;  posArr[idx*3+2] = 0;
          idx++;
        }
      }
      applyGeometry();
    }

    function buildInkPoints() {
      const total = state.inkN, L = state.inkRange;
      xArr   = new Float32Array(total);
      yArr   = new Float32Array(total);
      posArr = new Float32Array(total * 3);

      for (let i = 0; i < total; i++) {
        let x, y;
        if (Math.random() < 0.85) {
          const a = Math.random() * Math.PI * 2;
          const r = L * Math.sqrt(Math.random());
          x = r * Math.cos(a);  y = r * Math.sin(a);
        } else {
          x = (Math.random() * 2 - 1) * L;
          y = (Math.random() * 2 - 1) * L;
        }
        xArr[i] = x;  yArr[i] = y;
        posArr[i*3] = x;  posArr[i*3+1] = y;  posArr[i*3+2] = 0;
      }
      applyGeometry();
    }

    function applyGeometry() {
      geom.dispose();
      geom = new THREE.BufferGeometry();
      const attr = new THREE.BufferAttribute(posArr, 3);
      attr.setUsage(THREE.DynamicDrawUsage);
      geom.setAttribute("position", attr);
      points.geometry = geom;
      points.frustumCulled = false;
    }

    function stepMap(iters) {
      const mu = state.mu, twoOM = 2.0 * (1.0 - mu), cap = state.maxAbs;

      for (let rep = 0; rep < iters; rep++) {
        for (let i = 0, n = xArr.length; i < n; i++) {
          let x = xArr[i], y = yArr[i];

          const fx  = mu * x  + twoOM * x * x  / (1.0 + x * x);
          const x1  = y + fx;
          const fx1 = mu * x1 + twoOM * x1* x1 / (1.0 + x1* x1);
          const y1  = fx1 - x;

          if (!Number.isFinite(x1) || !Number.isFinite(y1) ||
              Math.abs(x1) > cap || Math.abs(y1) > cap) {
            const L = state.mode === "grid" ? state.gridRange : state.inkRange;
            xArr[i] = (Math.random() * 2 - 1) * L;
            yArr[i] = (Math.random() * 2 - 1) * L;
          } else {
            xArr[i] = x1;  yArr[i] = y1;
          }
        }
      }

      for (let i = 0, n = xArr.length; i < n; i++) {
        posArr[i*3]   = xArr[i];
        posArr[i*3+1] = yArr[i];
      }
      geom.attributes.position.needsUpdate = true;
      state.step += iters;
    }

    function renderGrid() {
      renderer.setRenderTarget(null);
      renderer.setClearColor(0x000000, 1);
      renderer.clear(true, true, true);
      renderer.render(simScene, orthoCam);
    }

    function renderInk() {
      // points → rtPts
      renderer.setRenderTarget(rtPts);
      renderer.setClearColor(0x000000, 0);
      renderer.clear(true, true, true);
      renderer.render(simScene, orthoCam);

      // feedback: rtB = decay·blur(rtA) + rtPts
      feedbackMat.uniforms.uPrev.value  = rtA.texture;
      feedbackMat.uniforms.uAdd.value   = rtPts.texture;
      feedbackMat.uniforms.uDecay.value = state.decay;
      feedbackMat.uniforms.uBlur.value  = state.blur;

      quadFeedback.visible = true;   quadDisplay.visible = false;
      renderer.setRenderTarget(rtB);
      renderer.setClearColor(0x000000, 1);
      renderer.clear(true, true, true);
      renderer.render(quadScene, quadCam);

      // colorise rtB → screen
      displayMat.uniforms.uTex.value  = rtB.texture;
      displayMat.uniforms.uEdge.value = state.edgeStrength;

      quadFeedback.visible = false;  quadDisplay.visible = true;
      renderer.setRenderTarget(null);
      renderer.setClearColor(0x000000, 1);
      renderer.clear(true, true, true);
      renderer.render(quadScene, quadCam);

      // ping-pong
      const tmp = rtA; rtA = rtB; rtB = tmp;
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      stepMap(state.itersPerFrame);
      elStepBox.textContent = `Step : ${state.step}`;
      state.mode === "grid" ? renderGrid() : renderInk();
    }
  </script>
</body>
</html>
